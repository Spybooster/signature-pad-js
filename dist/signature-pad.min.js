(()=>{var a=class{constructor(t,s={}){this.container=t,this.opts=Object.assign({background:"#fff",color:"#000",thickness:2,guideline:!1,guidelineColor:"#a0a0a0",guidelineOffset:50,guidelineIndent:10,disableResize:!1,undoLimit:10,syncField:null,syncFormat:"JSON",svgStyles:!1,onChange:null},s),this.lines=[],this._initCanvas(),this._attachEvents(),this.opts.disableResize||window.addEventListener("resize",()=>this._resizeCanvas()),this.clear(!1)}_initCanvas(){this.canvas=document.createElement("canvas"),this.container.innerHTML="",this.container.appendChild(this.canvas),this.ctx=this.canvas.getContext("2d"),this._resizeCanvas(),this.ctx.lineCap="round",this.ctx.lineJoin="round"}_resizeCanvas(){let{width:t,height:s}=this.container.getBoundingClientRect(),i=this.canvas.toDataURL();this.canvas.width=t,this.canvas.height=s,this.ctx=this.canvas.getContext("2d"),this._drawBackground(),this._redrawLines()}_attachEvents(){let t=s=>this._startStroke(s);this.canvas.addEventListener("pointerdown",t),this.canvas.addEventListener("pointermove",s=>this._continueStroke(s)),document.addEventListener("pointerup",s=>this._endStroke(s))}_startStroke({clientX:t,clientY:s}){this.points=[],this._addPoint(t,s),this.isDrawing=!0}_continueStroke({clientX:t,clientY:s}){if(this.isDrawing&&(this._addPoint(t,s),this.points.length>1)){let[i,e]=this.points.slice(-2);this.ctx.strokeStyle=this.opts.color,this.ctx.lineWidth=this.opts.thickness,this.ctx.beginPath(),this.ctx.moveTo(i.x,i.y),this.ctx.lineTo(e.x,e.y),this.ctx.stroke()}}_endStroke(){if(this.isDrawing){if(this.isDrawing=!1,this.points.length===1){let t=this.points[0];this.ctx.beginPath(),this.ctx.arc(t.x,t.y,this.opts.thickness/2,0,2*Math.PI),this.ctx.fillStyle=this.opts.color,this.ctx.fill()}this.lines.push(this.points.slice()),this.lines.length>this.opts.undoLimit&&this.lines.shift(),this._triggerChange()}}_addPoint(t,s){let i=this.canvas.getBoundingClientRect();this.points.push({x:t-i.left,y:s-i.top})}_drawBackground(){if(this.ctx&&(this.ctx.fillStyle=this.opts.background,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.opts.guideline)){let t=this.canvas.height-this.opts.guidelineOffset;this.ctx.strokeStyle=this.opts.guidelineColor,this.ctx.lineWidth=1,this.ctx.beginPath(),this.ctx.moveTo(this.opts.guidelineIndent,t),this.ctx.lineTo(this.canvas.width-this.opts.guidelineIndent,t),this.ctx.stroke()}}_redrawLines(){this.ctx&&(this._drawBackground(),this.ctx.strokeStyle=this.opts.color,this.ctx.lineWidth=this.opts.thickness,this.lines.forEach(t=>{this.ctx.beginPath(),t.forEach((s,i)=>{i===0?this.ctx.moveTo(s.x,s.y):this.ctx.lineTo(s.x,s.y)}),this.ctx.stroke()}))}_triggerChange(){if(this.opts.syncField){let t;switch(this.opts.syncFormat){case"PNG":t=this.toDataURL();break;case"SVG":t=this.toSVG();break;default:t=this.toJSON()}this.opts.syncField.value=t}typeof this.opts.onChange=="function"&&this.opts.onChange(this)}clear(t=!0){this.lines=[],this._drawBackground(),t&&this._triggerChange()}undo(){this.lines.pop(),this._redrawLines(),this._triggerChange()}isEmpty(){return this.lines.length===0}toJSON(){return JSON.stringify({lines:this.lines})}toDataURL(t="image/png",s){return this.canvas.toDataURL(t,s)}toSVG(){let{background:t,color:s,thickness:i,svgStyles:e}=this.opts,h=this.canvas.width,o=this.canvas.height,c=e?`style="fill:${t};"`:`fill="${t}"`,l=e?`style="fill:none;stroke:${s};stroke-width:${i};"`:`fill="none" stroke="${s}" stroke-width="${i}"`,n=`<svg xmlns="http://www.w3.org/2000/svg" width="${h}" height="${o}">`;return n+=`<rect ${c} x="0" y="0" width="${h}" height="${o}"/>`,n+=`<g ${l}>`,this.lines.forEach(g=>{let d=g.map(r=>`${r.x},${r.y}`).join(" ");n+=`<polyline points="${d}" />`}),n+="</g></svg>",n}draw(t){switch(this.clear(!1),typeof t){case"string":if(t.startsWith("data:")){let s=new Image;s.onload=()=>this.ctx.drawImage(s,0,0),s.src=t}else if(t.trim().startsWith("<svg")){let s=new DOMParser().parseFromString(t,"image/svg+xml");this._parseSVG(s)}else this.draw(JSON.parse(t));break;default:t.lines&&(this.lines=t.lines,this._redrawLines())}this._triggerChange()}_parseSVG(t){let s=Array.from(t.querySelectorAll("polyline"));this.lines=s.map(i=>(i.getAttribute("points")||"").split(" ").map(e=>{let[h,o]=e.split(",").map(Number);return{x:h,y:o}})),this._redrawLines()}},u=a;})();
/**
 * SignaturePad.js v1.0.0
 * --------------------------------------------------------
 * Custom lightweight signature pad with undo, resize, sync,
 * and SVG/PNG/JSON export support.
 *
 * @version     1.0.0
 * @author      Niel - Spybooster
 * @license     MIT (https://opensource.org/licenses/MIT)
 * --------------------------------------------------------
 * Usage:
 *
 * const sigPad = new SignaturePad(document.getElementById('sig-container'), {
 *     background: '#fff',
 *     color: '#000',
 *     thickness: 2,
 *     guideline: true,
 *     syncField: document.getElementById('signature64'),
 *     syncFormat: 'PNG',
 *     onChange: () => console.log("Signature updated.")
 * });
 *
 * sigPad.clear(); // Clear signature
 * sigPad.undo();  // Undo last stroke
 * sigPad.toDataURL(); // Export as image
 * sigPad.toJSON();    // Export as JSON
 * sigPad.toSVG();     // Export as SVG
 * --------------------------------------------------------
 */
